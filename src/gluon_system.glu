let { negate } = import! std.num
let entity = import! entity

let { AddComponent, Pos, Vel, eq_Pos, new_pos, vel_component, ? } = import! gluon_component

let new_vel x y : Float -> Float -> Pos = { x, y }

let add_component ?c l r a e : [AddComponent a] -> LazyUpdate -> ReflectionTable -> a -> Entity -> () =
    entity.add_component l r c.component_name a e

let num_Pos : Num Pos = {
    ord = { eq = eq_Pos, compare = \_ _ -> error "Unimplemented" },
    (+) = \l r -> { x = l.x + r.x, y = l.y + r.y },
    (-) = \l r -> { x = l.x - r.x, y = l.y - r.y },
    (*) = \l r -> { x = l.x * r.x, y = l.y * r.y },
    (/) = \l r -> { x = l.x / r.x, y = l.y / r.y },
    negate = \x -> { x = negate x.x, y = negate x.y },
}


let update r : { pos : Pos, dt: DeltaTime, entities : EntitiesRes, lazy_update: LazyUpdate, reflection_table: ReflectionTable } -> { pos : Pos } =
    let { pos, dt, entities, lazy_update, reflection_table } = r
    let e = entity.create entities
    add_component lazy_update reflection_table pos e
    add_component lazy_update reflection_table pos e
    { pos = pos + { x = 0., y = 1.0 * dt } }

update
