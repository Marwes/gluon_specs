let { negate } = import! std.num
let entity = import! entity
    
#[derive(Eq, Show)]
type Pos = { x : Float, y : Float }

let num_Pos : Num Pos = {
    ord = { eq = eq_Pos, compare = \_ _ -> error "Unimplemented" },
    (+) = \l r -> { x = l.x + r.x, y = l.y + r.y },
    (-) = \l r -> { x = l.x - r.x, y = l.y - r.y },
    (*) = \l r -> { x = l.x * r.x, y = l.y * r.y },
    (/) = \l r -> { x = l.x / r.x, y = l.y / r.y },
    negate = \x -> { x = negate x.x, y = negate x.y },
}

let update r : { pos : Pos, dt: Float, entities : Entities, lazy_update: LazyUpdate } -> { pos : Pos } =
    let { pos, dt, entities, lazy_update } = r
    let e = entity.create entities
    entity.add_component lazy_update "pos" pos e
    entity.add_component lazy_update "vel" pos e
    { pos = pos + { x = 0., y = 1.0 * dt } }

update
